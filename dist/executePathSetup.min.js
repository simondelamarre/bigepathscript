var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))},__asyncValues=this&&this.__asyncValues||function(o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,m=o[Symbol.asyncIterator];return m?m.call(o):(o="function"==typeof __values?__values(o):o[Symbol.iterator](),i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i);function verb(n){i[n]=o[n]&&function(v){return new Promise((function(resolve,reject){(function(resolve,reject,d,v){Promise.resolve(v).then((function(v){resolve({value:v,done:d})}),reject)})(resolve,reject,(v=o[n](v)).done,v.value)}))}}};import scrollToBottom from"./events/scrollToBottom";import scrollToElement from"./events/scrollToElement";import productScheme from"./parsers/productScheme";export const bigePath=setup=>__awaiter(void 0,void 0,void 0,(function*(){return{static:{},list:[]}}));export const processLoadMoreButton=(setup,response,callback)=>__awaiter(void 0,void 0,void 0,(function*(){var e_1,_a;try{for(var _c,_b=__asyncValues(setup.lists);!(_c=yield _b.next()).done;){const list=_c.value;response=response.concat(response,yield processListItem(list.target.selector))}}catch(e_1_1){e_1={error:e_1_1}}finally{try{_c&&!_c.done&&(_a=_b.return)&&(yield _a.call(_b))}finally{if(e_1)throw e_1.error}}const loadMore=document.querySelector(setup.navigation.loadMoreSelector);if(!loadMore)return callback(response),response;loadMore.click(),setTimeout((function(){processLoadMoreButton(setup,response,callback)}),1e3)}));export const processScrollToBottom=(setup,response,callback)=>__awaiter(void 0,void 0,void 0,(function*(){var e_2,_d;yield scrollToBottom(window.document.body,500);try{for(var _f,_e=__asyncValues(setup.lists);!(_f=yield _e.next()).done;){const list=_f.value;response=response.concat(response,yield processListItem(list.target.selector))}}catch(e_2_1){e_2={error:e_2_1}}finally{try{_f&&!_f.done&&(_d=_e.return)&&(yield _d.call(_e))}finally{if(e_2)throw e_2.error}}return callback(response),response}));export const processListItem=selector=>{let response=[];return new Promise(((resolve,reject)=>__awaiter(void 0,void 0,void 0,(function*(){var e_3,_a;const listTarget=document.querySelectorAll(selector);try{try{for(var listTarget_1_1,listTarget_1=__asyncValues(listTarget);!(listTarget_1_1=yield listTarget_1.next()).done;){const listTar=listTarget_1_1.value;(yield getItem(listTar))&&response.push()}}catch(e_3_1){e_3={error:e_3_1}}finally{try{listTarget_1_1&&!listTarget_1_1.done&&(_a=listTarget_1.return)&&(yield _a.call(listTarget_1))}finally{if(e_3)throw e_3.error}}resolve(response)}catch(err){reject(err)}}))))};export const getItem=listTar=>new Promise(((resolve,reject)=>__awaiter(void 0,void 0,void 0,(function*(){try{if(listTar.classList.contains("bigeProcessed"))resolve(null);else{yield scrollToElement(window.document.body,listTar),listTar.classList.add("bigeProcessed");const scheme=yield productScheme(listTar);resolve(scheme)}}catch(err){reject("fail")}}))));window.bigePath=bigePath;